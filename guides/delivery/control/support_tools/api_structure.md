---
title: Control REST APIs Common Structure
---

Control APIs are RESTful APIs that leverage HTTP's well-defined and consistent message envelope. RESTful architectures are designed for resource passing by placing method information in the method, scoping information in the path, client information in the headers, and the representation of the resource in the body.

The elements of the HTTP request are:
-   Method
-   URI path and parameters
-   Header
-   Representation of resource in the body or document

The elements of the HTTP responses are:
-   Response code
-   Header
-   Representation of resource in the body or document

## HTTP Requests  {/**/}

### URI Path and Parameters  {/**/}

The general form of the URL for requests is:

`https://host:port/${api-name}/${version}/${resource-name}/${sub-level}/${resourceId}?${params}`

where:
-   host and port - define the host and port where the application lives (port is optional)
-   api-name - API name (for example, purge-api)
-   version - the API version for this feature (e.g., v1)
-   resource-name - name of the resource requested (e.g., request)
-   sub-level - optional level to further specify the requested resource
-   resourceId - resource identifier, if applicable for the method
-   params - additional parameters for pagination, search, authentication, etc.

<Callout type="info">Unless otherwise noted, arguments are case-sensitive.</Callout>

### API Version  {/**/}

The REST APIs are subject to version control. The version number of an API appears in its URI. For example, this URI structure requests version 1 of an API: `https://host:port/api-name/v1/resource-names`

Notes:
-   The API version number is an integer with v prefix, such as v1 or v2.
-   The API version is independent of the release number.
-   The API version may or may not change with a new release. The API version number changes only when updates to the API break the API contract, requiring changes in the code that uses the API. A change to the API does not necessarily require a change to the API version number.
-   For multiple API versions, each version will ideally support at least two API versions: the latest API version and the previous API version.

#### Media Type  {/**/}

Some REST API requests accept resources, and most REST API responses return resources. These resources can be in either JSON or XML format; the default is JSON. The media type of the request resource must be specified in the Content-Type header (application/json or application/xml). The media type of the response resource is specified in the URI (responseType\=json or responseType\=xml) or in the Accept header (application/json or application/xml).

#### Parameters  {/*parameters*/}

URI parameters can be for pagination, search, authentication, and/or specific parameters for an API resource.

## Authentication  {/*authentication*/}

The Edgio REST APIs use a combination of symmetric key cryptography and Hashed Message Authentication Code (HMAC) for message authentication and user identification.

To secure all calls to the API, an HMAC digest signature is applied to each request by using the following authentication headers:

-   **X-LLNW-Security-Principal** – name of user performing the request. Services look up shared keys by username to authenticate a message. Since shared keys are stored on a per-user basis, to impersonate another user, an attacker would have to know both the username and the shared key for that user.
-  **X-LLNW-Security-Timestamp** – request time in milliseconds. Prevents replay attacks. If the timestamp is more than X seconds old (usually 300), the message expires, and an error code is returned. Note: System clock skew minimization is an important consideration for message expiration.
-   **X-LLNW-Security-Token** – MAC hash-generated with the user's shared key. It is calculated based on data that is sent to the server. This token is generated twice: once by the client and once by the server to compare with the one passed by the client. If the token provided by the client matches the token generated by the server, the message is authentic. Shared key is a large unique key created for use with the "HmacSHA256" MAC algorithm. Control maintains a unique and enciphered shared key for every user in the system. It is stored in HEX format and should be decoded to ASCII before usage (see code samples below).  Users may access or regenerate this key at any time by using tools in Control under My Settings > Edit My Profile.
    -   X-LLNW-Security-Token is formed by applying a MAC digest for the "data string" (for example, `REQUEST_METHOD + URL + QUERY_STRING [if present] + TIMESTAMP + REQUEST_BODY` (if present)).

### Java Sample Code for HMAC Generation   {/*java-sample*/}

```java
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
public class HMACGenerationExample {
    private static String HMAC_ALGORITHM = "HmacSHA256";
    public static void main(String[] args) throws IOException,
      InterruptedException, InvalidKeyException, NoSuchAlgorithmException,
      DecoderException {
        String sharedKey = "your_key";
        //sharedKey is what you see in Control on Edit My Profile page
        String url = "<api base url>";
        /* base url example: "https://control.llnw.com/
           traffic-reporting-api/v2" */
        String queryString = "<query string parameters>";
        /*queryString example: "shortname=bulkget&service=http&
          reportDuration=day&startDate=2012-01-01" */
        String postData = "{param1: 123, param2: 456}";
        byte[] rawHmac = generateMac(sharedKey, "GET", url, queryString,
                         postData);
        String hmac = new String(Hex.encodeHex(rawHmac));
        System.out.println(hmac);
    }
    private static byte[] generateMac(String sharedKey, String httpMethod,
                                      String url, String queryString,
                                      String postBody)
        throws NoSuchAlgorithmException, InvalidKeyException,
        IllegalStateException, UnsupportedEncodingException,
        DecoderException {
        byte[] decodedSharedKey = Hex.decodeHex(sharedKey.toCharArray());
        long timestamp = System.currentTimeMillis();
        String dataString;
        if (queryString == null) {
            dataString = httpMethod.toUpperCase() + url + timestamp;
        } else {
            dataString = httpMethod.toUpperCase() + url + queryString +
            timestamp;
        }

        if (postBody != null) {
            dataString = dataString + postBody;
        }
        SecretKeySpec keySpec = new SecretKeySpec(decodedSharedKey,
                                HMAC_ALGORITHM);
        Mac mac = Mac.getInstance(HMAC_ALGORITHM);
        mac.reset();
        mac.init(keySpec);
        return mac.doFinal(dataString.getBytes("UTF-8"));
    }
}
```
### Python Sample Code for HMAC Generation   {/*python-sample*/}

```python
import hashlib
import hmac
import time
try: import simplejson as json
except ImportError: import json
class HMACSample:
    def generateSecurityToken(self, url, httpMethod, apiKey, queryParameters=None, postData=None):
            timestamp = str(int(round(time.time()*1000)))
            datastring = httpMethod + url
            if queryParameters != None : datastring += queryParameters
            datastring += timestamp
            if postData != None : datastring += postData
            token = hmac.new(apiKey.decode('hex'), msg=datastring, digestmod=hashlib.sha256).hexdigest()
            return token
if __name__ == '__main__':
    apiEndpoint = "<api base url>"
    #example: "https://control.llnw.com/traffic-reporting-api/v2"

    #what you see in Control on Edit My Profile page#
    apiKey = "your_key";

    queryParameters = "<query string parameters>"
    #example: "shortname=bulkget&service=http&reportDuration=day&startDate=2012-01-01"
    postData = "{param1: 123, param2: 456}"
    tool = HMACSample()
    hmac = tool.generateSecurityToken(url=apiEndpoint, httpMethod="GET", queryParameters=queryParameters, postData=postData, apiKey=apiKey)
    print json.dumps(hmac, indent=4)
```

## Request Header {/*request-header*/}

The *Accept* `HTTP Header` can specify the response format. The default is `JSON`.

`Accept=application/json`

The *Content-Type* `HTTP Header` can specify the format of the request body. This header is required for all resources that require a request body.

`Content-Type=json`

The HTTP `X-LLNW-Security-Token`, `X-LLNW-Security-Principal`, `X-LLNW-Security-Timestamp` headers form the authentication envelope.

    `X-LLNW-Security-Token=<mac>`

    `X-LLNW-Security-Principal=<username>`

    `X-LLNW-Security-Timestamp=<now in milliseconds>`

### Representation of Resource in the Body or Document {/*representation*/}

Some APIs expect a payload of information in JSON format in the request body for `PUT` or `POST` methods. This payload is known as the body or document of the request and is a representation of the resource for the API. The format must specified with the `Content-Type` header.

## HTTPS Responses{/*http-responses*/}

A response header, returned for each API request, contains:
-   one of the [HTTP Response Status Codes](#http-response-status-codes)
-   the returned media type in the `Content-Type` header (for example, `application/json;charset=UTF-8`)

The response body, returned for each API request, contains either:
-   a status entity or
-   a response entity (representation of the resource)

The format of the response body is determined by the `responseType` parameter or Accept `HTTP Header` in the request.

### HTTP Response Status Codes{/*http-response-status-codes*/}

|   HTTP Status Code  | Name | Description |
| --- | --- | --- |
| 5xx | Server-Side Error | Any server-side error |
| 200 | OK  | Request was processed as expected. |
| 201 | Created | Request created an entity. |
| 202 | Accepted | Request was processed as expected. |
| 304 | Not Modified | The requested resource has not been modified, and the client's cached representation is still valid. |
| 400 | Bad Request | The request could not be understood due to bad syntax. |
| 401 | Unauthorized | Client is not authenticated or does not have sufficient permission to perform this request.<br /><br />Similar to 403 Forbidden but specifically for use when authentication is possible but has failed or has not yet been provided. |
| 403 | Forbidden | The request was a legal request, but the server is refusing to respond to it.<br /><br />Unlike a 401 Unauthorized response, authenticating will make no difference. |
| 404 | Not found | The requested resource could not be found at this location (URI), but may be available again in the future. Subsequent requests by the client are permissible. |
